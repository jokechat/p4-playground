# QoS - Quality of Service

## Overview

This example implements Quality of Service (QoS) functionality on a smart NIC using P4, enabling differentiated treatment of network traffic based on priority levels. The P4 program processes packets in both ingress and egress pipelines:

* **Ingress (network to host)**: Combines the 3-bit PCP field from VLAN headers and 6-bit DSCP field from IPv4 headers to perform a ternary table lookup, mapping to a Class of Service (CoS) value. This value is assigned to both `icos` and `ocos` fields in the output metadata.

* **Egress (host to network)**: Uses the `chan_id` field from input metadata to perform an exact match table lookup, mapping to an `ochan` value stored in the output metadata.

The P4 implementation focuses solely on these classification and mapping functions. Subsequent processing is handled by other NIC components: the IPeg module uses `icos` for resource allocation and `ocos` for scheduling decisions (though they are set identically in this example, they can be configured differently to prioritize specific traffic). For egress, the `chan_id` input is generated by the NIC's VPE module based on VF mappings, which the P4 program does not need to interpret.

This example demonstrates how P4 enables hardware-accelerated traffic classification and priority handling in smart NICs.

## Learning Objectives

By completing this exercise, you will learn:

* **QoS Fundamentals**: Implement traffic classification and prioritization
* **Multi-Field Matching**: Combine VLAN PCP and IPv4 DSCP fields for classification
* **Table Types**: Use ternary and exact match tables for different mapping scenarios
* **Metadata Management**: Handle input/output metadata for QoS processing
* **Smart NIC Pipeline Integration**: Coordinate with specialized hardware modules (IPeg, VPE)

## What You'll Implement

The P4 program implements QoS functionality that:

1. **Ingress Processing**:
* Extracts VLAN PCP (3 bits) and IPv4 DSCP (6 bits) fields
* Performs ternary table lookup using these priority fields
* Maps to CoS value stored in `icos` and `ocos` metadata
2. **Egress Processing**:
* Uses `chan_id` from input metadata
* Performs exact match table lookup
* Maps to output channel (`ochan`) in metadata
3. **Metadata Propagation**:
* Maintains QoS state between pipeline stages
* Enables downstream NIC modules to apply QoS policies

## QoS Concepts

### What is QoS?

Quality of Service refers to technologies that:

* Provide differentiated treatment for different traffic types
* Ensure critical traffic meets performance requirements
* Manage network resources efficiently
* Prevent congestion for high-priority applications

### Traffic Classification Mechanisms

This implementation uses standard priority markers:

* **PCP (Priority Code Point)**: 3-bit field in VLAN headers (0-7 range)
  * Used for Layer 2 priority marking
  * Typically set by network switches
* **DSCP (Differentiated Services Code Point)**: 6-bit field in IPv4 headers (0-63 range)
  * Used for Layer 3 priority marking
  * Provides finer granularity than PCP
  * Defines Per-Hop Behaviors (PHBs) for traffic treatment
* **CoS (Class of Service)**: Internal classification value that maps to specific handling policies

### Ingress vs. Egress QoS

* **Ingress QoS**: Focuses on traffic classification as it enters the system
  * Determines resource allocation for received traffic
  * Sets scheduling priorities for host delivery
* **Egress QoS**: Focuses on traffic shaping as it leaves the system
  * Manages bandwidth allocation for outgoing traffic
  * Ensures compliance with service level agreements

## Network Topology

```
      Host 1                           Host 2
   10.0.1.1/24                      10.0.1.2/24
MAC: c2:0c:20:4a:23:65        MAC: 62:9b:0c:db:ac:20
        │                                │
        │                                │
   ┌────┴────┐                      ┌────┴────┐
   │  NIC 1  │──────────────────────│  NIC 2  │
   └─────────┘                      └─────────┘

Qos P4 Program runs on all NICs (n1, n2)
NIC 1 sends packets, P4 engine maps chan_id to ochan in egress pipeline
NIC 2 receives packets, P4 engine maps dscp/pcp to icos/ocos in ingress pipeline
```

**Configuration**:

* **Smart NIC**: Runs P4 program implementing QoS classification
* **Ingress Path**: Handles traffic from network to host with PCP/DSCP-based classification
* **Egress Path**: Handles traffic from host to network with channel-based mapping
* **IPeg Module**: Uses `icos` for resource allocation and `ocos` for scheduling
* **VPE Module**: Generates `chan_id` based on VF mappings for egress processing

## P4 Program Details

### Headers Definition

```c
header vlan_t {
    bit<3>  pcp;
    bit<1>  cfi;
    bit<12> vid;
    bit<16> type;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<6>    dscp;
    bit<2>    ecn;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

struct headers_t {
    ethernet_t   ethernet;
    vlan_t       vlan;
    ipv4_t       ipv4;
}
```

### Parser Logic

```c
state start {
    pkt.extract(hdr.ethernet);
    transition select(hdr.ethernet.etherType) {
        TYPE_VLAN: parse_vlan;
        TYPE_IPV4: parse_ipv4;
        default: accept;
    }
}

state parse_vlan {
    pkt.extract(hdr.vlan);
    transition select(hdr.vlan.type) {
        TYPE_IPV4: parse_ipv4;
        default: accept;
    }
}

state parse_ipv4 {
    pkt.extract(hdr.ipv4);
    transition accept;
}
```

### Actions: icos/ocos mapping

```c
action get_mapping_cos(bit<3> cos) {
    ostd.icos = cos;
    ostd.ocos = cos;
}

action get_default_cos() {
    ostd.icos = 0;
    ostd.ocos = 0;
}
```

### cos_mapping Table

```c
table cos_mapping {
    key = {
        hdr.vlan.pcp: ternary;
        hdr.ipv4.dscp: ternary;
    }
    actions = {
        get_mapping_cos;
        get_default_cos;
    }
    default_action = get_default_cos();
    const entries = {
        (0x1 &&& 0x7, 0x0 &&& 0x0) : get_mapping_cos(4);  // match 3bit pcp to icos/ocos
        (0x2 &&& 0x7, 0x0 &&& 0x0) : get_mapping_cos(3);
        (0x0 &&& 0x0, 0x1 &&& 0x3F) : get_mapping_cos(2);  // match 6bit dscp to icos/ocos
        (0x0 &&& 0x0, 0x2 &&& 0x3F) : get_mapping_cos(1);
    }
    size = 128;
}
```

### Actions: ochan mapping

```c
action get_mapping_ochan(bit<4> chan) {
    ostd.ochan = chan;
}

action get_default_ochan() {
    ostd.ochan = 0;
}
```

### ochan_mapping Table

```c
table ochan_mapping {
    key = {
        istd.chan_id: exact;
    }
    actions = {
        get_mapping_ochan;
        get_default_ochan;
    }
    default_action = get_default_ochan();
    const entries = {  // match chan_id to ochan
        0 : get_mapping_ochan(1);
        1 : get_mapping_ochan(2);
    }
    size = 16;
}
```

Control applies cos_mapping table to set icos/ocos in output metadata during the ingress pipeline
Control applies ochan_mapping table to set ochan in output metadata during the egress pipeline

### Pipeline Structure

**Ingress Pipeline**:

* Parser: Extracts Ethernet, VLAN, and IPv4 headers
* Control:
  * Extracts PCP (from VLAN) and DSCP (from IPv4)
  * Performs ternary table lookup with these fields
  * Assigns resulting CoS value to `icos` and `ocos` metadata
* Deparser: Reassembles and emits headers

**Egress Pipeline**:

* Parser: Extracts basic headers
* Control:
  * Retrieves `chan_id` from input metadata
  * Performs exact table lookup
  * Assigns resulting `ochan` to output metadata
* Deparser: Reassembles and emits headers

## How to Run

In your shell, run:
```bash
cd tuna/app/qos
make
```
This will:
1. compile `qos.p4`
2. start the topo in Mininet and configure all NIC with the appropriate P4 program + table entries, and configure all hosts with the commands listed in [topology.json](./topology.json)
3. You should now see a Mininet command prompt. Try to ping between hosts in the topology:
   ```bash
   mininet> h2 python3 recv.py bmv2 &
   mininet> h1 python3 send.py bmv2 10.0.1.2 Dot1Q 0 2
   mininet> h1 python3 send.py bmv2 10.0.1.2 Dot1Q 1 2
   mininet> h1 python3 send.py bmv2 10.0.1.2 Dot1Q 2 2
   mininet> h1 python3 send.py bmv2 10.0.1.2 IPv4  0 2
   mininet> h1 python3 send.py bmv2 10.0.1.2 IPv4  1 2
   mininet> h1 python3 send.py bmv2 10.0.1.2 IPv4  2 2
   ```

   You will get:
   ```bash
   mininet> h2 python3 recv.py bmv2 &
   mininet> h1 python3 send.py bmv2 10.0.1.2 Dot1Q 0 2
   ###[ Ethernet ]### 
     dst       = 62:9b:0c:db:ac:20
     src       = c2:0c:20:4a:23:65
     type      = n_802_1Q
   ###[ 802.1Q ]### 
        prio      = 0
        id        = 0
        vlan      = 1
        type      = IPv4
   ###[ IP ]### 
           version   = 4
           ihl       = 5
           tos       = 0x0
           len       = 31
           id        = 1
           flags     = 
           frag      = 0
           ttl       = 64
           proto     = hopopt
           chksum    = 0x64dc
           src       = 10.0.1.1
           dst       = 10.0.1.2
           \options   \
   ###[ Raw ]### 
              load      = 'P4 qos test'
   
   .
   Sent 1 packets.
   .
   Sent 1 packets.
   mininet> h1 python3 send.py bmv2 10.0.1.2 Dot1Q 1 2
   ###[ Ethernet ]### 
     dst       = 62:9b:0c:db:ac:20
     src       = c2:0c:20:4a:23:65
     type      = n_802_1Q
   ###[ 802.1Q ]### 
        prio      = 1
        id        = 0
        vlan      = 1
        type      = IPv4
   ###[ IP ]### 
           version   = 4
           ihl       = 5
           tos       = 0x0
           len       = 31
           id        = 1
           flags     = 
           frag      = 0
           ttl       = 64
           proto     = hopopt
           chksum    = 0x64dc
           src       = 10.0.1.1
           dst       = 10.0.1.2
           \options   \
   ###[ Raw ]### 
              load      = 'P4 qos test'
   
   .
   Sent 1 packets.
   .
   Sent 1 packets.
   mininet> h1 python3 send.py bmv2 10.0.1.2 Dot1Q 2 2
   ###[ Ethernet ]### 
     dst       = 62:9b:0c:db:ac:20
     src       = c2:0c:20:4a:23:65
     type      = n_802_1Q
   ###[ 802.1Q ]### 
        prio      = 2
        id        = 0
        vlan      = 1
        type      = IPv4
   ###[ IP ]### 
           version   = 4
           ihl       = 5
           tos       = 0x0
           len       = 31
           id        = 1
           flags     = 
           frag      = 0
           ttl       = 64
           proto     = hopopt
           chksum    = 0x64dc
           src       = 10.0.1.1
           dst       = 10.0.1.2
           \options   \
   ###[ Raw ]### 
              load      = 'P4 qos test'
   
   .
   Sent 1 packets.
   .
   Sent 1 packets.
   mininet> h1 python3 send.py bmv2 10.0.1.2 IPv4  0 2
   ###[ Ethernet ]### 
     dst       = 62:9b:0c:db:ac:20
     src       = c2:0c:20:4a:23:65
     type      = IPv4
   ###[ IP ]### 
        version   = 4
        ihl       = 5
        tos       = 0x0
        len       = 31
        id        = 1
        flags     = 
        frag      = 0
        ttl       = 64
        proto     = hopopt
        chksum    = 0x64dc
        src       = 10.0.1.1
        dst       = 10.0.1.2
        \options   \
   ###[ Raw ]### 
           load      = 'P4 qos test'
   
   .
   Sent 1 packets.
   .
   Sent 1 packets.
   mininet> h1 python3 send.py bmv2 10.0.1.2 IPv4  1 2
   ###[ Ethernet ]### 
     dst       = 62:9b:0c:db:ac:20
     src       = c2:0c:20:4a:23:65
     type      = IPv4
   ###[ IP ]### 
        version   = 4
        ihl       = 5
        tos       = 0x4
        len       = 31
        id        = 1
        flags     = 
        frag      = 0
        ttl       = 64
        proto     = hopopt
        chksum    = 0x64d8
        src       = 10.0.1.1
        dst       = 10.0.1.2
        \options   \
   ###[ Raw ]### 
           load      = 'P4 qos test'
   
   .
   Sent 1 packets.
   .
   Sent 1 packets.
   mininet> h1 python3 send.py bmv2 10.0.1.2 IPv4  2 2
   ###[ Ethernet ]### 
     dst       = 62:9b:0c:db:ac:20
     src       = c2:0c:20:4a:23:65
     type      = IPv4
   ###[ IP ]### 
        version   = 4
        ihl       = 5
        tos       = 0x8
        len       = 31
        id        = 1
        flags     = 
        frag      = 0
        ttl       = 64
        proto     = hopopt
        chksum    = 0x64d4
        src       = 10.0.1.1
        dst       = 10.0.1.2
        \options   \
   ###[ Raw ]### 
           load      = 'P4 qos test'
   
   .
   Sent 1 packets.
   .
   Sent 1 packets.
   mininet>
   ```
4. Type `exit` to leave each xterm and the Mininet command line.
   Then, to stop mininet:
   ```bash
   make stop
   ```
   And to delete all pcaps, build files, and logs:
   ```bash
   make clean
   ```

## Expected Results

- You will find that the messages "`tuna_egress_output_metadata.ochan: 1`" is printed twelve times in the ./logs/n1.log.
- You will find that two messages "`tuna_ingress_output_metadata.icos: 0`" and "`tuna_ingress_output_metadata.ocos: 0`" are each printed four times in the ./logs/n1.log.
- You will find that the right messages "`tuna_ingress_output_metadata.icos: 1`", "`tuna_ingress_output_metadata.ocos: 1`", "`tuna_ingress_output_metadata.icos: 2`", "`tuna_ingress_output_metadata.ocos: 2`", "`tuna_ingress_output_metadata.icos: 3`", "`tuna_ingress_output_metadata.ocos: 3`", "`tuna_ingress_output_metadata.icos: 4`" and "`tuna_ingress_output_metadata.ocos: 4`" are each printed two times in the ./logs/n1.log.

## Understanding the QoS Logic

### Ingress Processing Flow (Network → Host)

1. **Packet arrives from network**
2. **Parser extracts headers**: Ethernet, VLAN (if present), and IPv4
3. **Priority field extraction**:
* Extracts 3-bit PCP from VLAN header
* Extracts 6-bit DSCP from IPv4 header
4. **Ternary table lookup**:
* Matches on PCP and/or DSCP values
* Each entry matches specific priority combinations
5. **CoS assignment**:
* Resulting CoS value stored in `icos` (ingress CoS)
* Same value stored in `ocos` (output CoS) for this example
6. **IPeg module processing**:
* Uses `icos` to determine resource allocation
* Uses `ocos` to determine scheduling priority
* Forwards packet to host with appropriate QoS treatment

### Egress Processing Flow (Host → Network)

1. **Packet arrives from host**
2. **VPE module processing** (prior to P4):
* Generates `chan_id` based on VF mappings
* Attaches `chan_id` to packet metadata
3. **P4 egress processing**:
* Retrieves `chan_id` from input metadata
* Performs exact match lookup in egress table
* Maps to `ochan` (output channel) in output metadata
4. **Subsequent processing**:
* NIC uses `ochan` to determine egress queue/port
* Packet forwarded to network with appropriate QoS

### Key Metadata Fields

* `icos`: Ingress Class of Service, used for resource allocation decisions
* `ocos`: Output Class of Service, used for scheduling decisions
* `chan_id`: Channel identifier from VPE module, based on VF mappings
* `ochan`: Output channel, determines egress path characteristics

## Key Concepts

### Separation of Classification and Enforcement

This implementation demonstrates a common QoS pattern:

* **P4 Program**: Handles high-speed traffic classification and mapping
* **Specialized Modules**: (IPeg, VPE) handle policy enforcement and complex logic
* **Metadata**: Serves as the interface between classification and enforcement

### Flexible Priority Mapping

The design supports flexible QoS implementations:

* `icos` and `ocos` can be independently set
* Allows different policies for resource allocation vs. scheduling
* Ternary matching enables complex priority rules
* Exact matching provides efficient channel mapping

## Production Considerations

A production QoS implementation would typically include:

1. **Extended Protocol Support**: IPv6, MPLS, and other protocol marking
2. **Traffic Shaping**: Rate limiting and bandwidth allocation
3. **Congestion Management**: Advanced scheduling algorithms (WFQ, PQ, DRR)
4. **Dynamic Configuration**: Runtime updates to QoS policies
5. **Per-Flow Policing**: Preventing individual flows from dominating resources
6. **QoS Monitoring**: Metrics collection for policy effectiveness
7. **Hierarchical QoS**: Multiple levels of traffic classification

## What's Next?

After understanding basic QoS implementation:

* [MULTICAST](../multicast): Integrate with multicast transmission mechanisms
* Extend to support IPv6 traffic classes
* Implement independent `icos` and `ocos` mappings for advanced scenarios
* Add traffic metering and shaping in the P4 pipeline
* Explore hierarchical QoS with multiple classification levels
